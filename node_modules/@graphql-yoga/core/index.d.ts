import { GraphiQLOptions, handleRequest } from '@graphql-yoga/handler';
import { GraphQLSchema } from 'graphql';
import { Plugin, GetEnvelopedFn, UseMaskedErrorsOpts } from '@envelop/core';
import { IResolvers, TypeSource } from '@graphql-tools/utils';
export declare type ServerCORSOptions = {
    origin: string[];
    methods?: string[];
    allowedHeaders?: string[];
    exposedHeaders?: string[];
    credentials?: boolean;
    maxAge?: number;
    optionsSuccessStatus?: number;
};
export declare type YogaLogger = Pick<Console, 'debug' | 'error' | 'warn' | 'info'>;
/**
 * Configuration options for the server
 */
export declare type ServerOptions<TContext> = {
    /**
     * Envelop Plugins
     * @see https://envelop.dev/plugins
     */
    plugins?: Array<Plugin<TContext>>;
    /**
     * Enable logging
     * @default true
     */
    enableLogging?: boolean;
    /**
     * Custom logger
     *
     * @default console
     */
    logger?: YogaLogger;
    /**
     * Allow introspection query. This is useful for exploring the API with tools like GraphiQL.
     * If you are making a private GraphQL API,
     * it is suggested that you disable this in production so that
     * potential malicious API consumers do not see what all operations are possible.
     *
     * You can learn more about GraphQL introspection here:
     * @see https://graphql.org/learn/introspection/
     *
     * Default: `true`
     */
    introspection?: boolean;
    /**
     * Prevent leaking unexpected errors to the client. We highly recommend enabling this in production.
     * If you throw `GraphQLServerError`/`EnvelopError` within your GraphQL resolvers then that error will be sent back to the client.
     *
     * You can lean more about this here:
     * @see https://www.envelop.dev/plugins/use-masked-errors
     *
     * Default: `false`
     */
    maskedErrors?: boolean | UseMaskedErrorsOpts;
    /**
     * Context
     */
    context?: (req: Request) => Promise<TContext> | Promise<TContext>;
    cors?: ((request: Request) => ServerCORSOptions) | ServerCORSOptions | boolean;
    /**
     * GraphiQL options
     *
     * Default: `true`
     */
    graphiql?: GraphiQLOptions | boolean;
} & ({
    schema: GraphQLSchema;
} | {
    typeDefs: TypeSource;
    resolvers?: IResolvers<any, TContext>;
});
/**
 * Base class that can be extended to create a GraphQL server with any HTTP server framework.
 * @internal
 */
export declare class Server<TContext> {
    /**
     * Request handler for helix
     */
    readonly handleRequest: typeof handleRequest;
    readonly schema: GraphQLSchema;
    /**
     * Instance of envelop
     */
    readonly getEnveloped: GetEnvelopedFn<TContext>;
    logger: YogaLogger;
    readonly corsOptionsFactory?: (request: Request) => ServerCORSOptions;
    readonly graphiql: GraphiQLOptions | false;
    constructor(options: ServerOptions<TContext>);
}
export declare function createServer<TContext>(options: ServerOptions<TContext>): Server<TContext>;
export { renderGraphiQL } from '@graphql-yoga/handler';
