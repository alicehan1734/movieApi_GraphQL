'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const handler = require('@graphql-yoga/handler');
const core = require('@envelop/core');
const disableIntrospection = require('@envelop/disable-introspection');
const validationCache = require('@envelop/validation-cache');
const parserCache = require('@envelop/parser-cache');
const schema = require('@graphql-tools/schema');

const DEFAULT_CORS_OPTIONS = {
    origin: ['*'],
    methods: ['GET', 'HEAD', 'PUT', 'PATCH', 'POST', 'DELETE'],
    optionsSuccessStatus: 204,
};
/**
 * Base class that can be extended to create a GraphQL server with any HTTP server framework.
 * @internal
 */
class Server {
    constructor(options) {
        var _a;
        /**
         * Request handler for helix
         */
        this.handleRequest = handler.handleRequest;
        this.schema =
            'schema' in options
                ? options.schema
                : schema.makeExecutableSchema({
                    typeDefs: options.typeDefs,
                    resolvers: options.resolvers,
                });
        this.logger = options.enableLogging
            ? options.logger || console
            : {
                debug: () => { },
                error: () => { },
                warn: () => { },
                info: () => { },
            };
        const maskedErrors = options.maskedErrors || false;
        const introspectionEnabled = (_a = options.introspection) !== null && _a !== void 0 ? _a : true;
        this.getEnveloped = core.envelop({
            plugins: [
                // Use the schema provided by the user
                core.useSchema(this.schema),
                // Performance things
                parserCache.useParserCache({
                    errorCache: new Map(),
                    documentCache: new Map(),
                }),
                validationCache.useValidationCache({
                    cache: new Map(),
                }),
                // Log events - useful for debugging purposes
                core.enableIf(!!options.enableLogging, core.useLogger({
                    logFn: (eventName, events) => {
                        var _a, _b, _c, _d, _e;
                        if (eventName === 'execute-start') {
                            const context = events.args.contextValue;
                            const query = (_b = (_a = context.request) === null || _a === void 0 ? void 0 : _a.body) === null || _b === void 0 ? void 0 : _b.query;
                            const variables = (_d = (_c = context.request) === null || _c === void 0 ? void 0 : _c.body) === null || _d === void 0 ? void 0 : _d.variables;
                            const headers = (_e = context.request) === null || _e === void 0 ? void 0 : _e.headers;
                            this.logger.debug(eventName);
                            this.logger.debug(query, 'query');
                            // there can be no variables
                            if (variables && Object.keys(variables).length > 0) {
                                this.logger.debug(variables, 'variables');
                            }
                            this.logger.debug(headers, 'headers');
                        }
                        if (eventName === 'execute-end') {
                            this.logger.debug(eventName);
                            this.logger.debug(events.result, 'response');
                        }
                    },
                })),
                core.enableIf(!introspectionEnabled, disableIntrospection.useDisableIntrospection()),
                core.enableIf(!!maskedErrors, core.useMaskedErrors(typeof maskedErrors === 'object' ? maskedErrors : undefined)),
                ...(options.context != null
                    ? [
                        core.useExtendContext(typeof options.context === 'function'
                            ? options.context
                            : () => options.context),
                    ]
                    : []),
                ...(options.plugins || []),
            ],
        });
        if (options.cors != null) {
            if (typeof options.cors === 'function') {
                const userProvidedCorsOptionsFactory = options.cors;
                this.corsOptionsFactory = (...args) => {
                    const corsOptions = userProvidedCorsOptionsFactory(...args);
                    return {
                        ...DEFAULT_CORS_OPTIONS,
                        ...corsOptions,
                    };
                };
            }
            else if (typeof options.cors === 'object') {
                const corsOptions = {
                    ...DEFAULT_CORS_OPTIONS,
                    ...options.cors,
                };
                this.corsOptionsFactory = () => corsOptions;
            }
            else if (typeof options.cors === 'boolean') {
                this.corsOptionsFactory = () => DEFAULT_CORS_OPTIONS;
            }
        }
        if (typeof options.graphiql === 'object' || options.graphiql === false) {
            this.graphiql = options.graphiql;
        }
        else {
            this.graphiql = introspectionEnabled ? {} : false;
        }
    }
}
function createServer(options) {
    return new Server(options);
}

Object.defineProperty(exports, 'renderGraphiQL', {
    enumerable: true,
    get: function () {
        return handler.renderGraphiQL;
    }
});
exports.Server = Server;
exports.createServer = createServer;
