import { ReadableStream, Response } from "cross-undici-fetch";
import { encodeString } from './encode-string.mjs';
export const DEFAULT_TRANSFORM_RESULT_FN = (result) => result;
export function getRegularResponse(executionResult, transformResult = DEFAULT_TRANSFORM_RESULT_FN) {
    const transformedResult = transformResult(executionResult);
    const responseBody = JSON.stringify(transformedResult);
    const decodedString = encodeString(responseBody);
    const headersInit = {
        "Content-Type": "application/json",
        "Content-Length": decodedString.byteLength.toString(),
    };
    const responseInit = {
        headers: headersInit,
        status: 200,
    };
    return new Response(decodedString, responseInit);
}
export function getMultipartResponse(asyncExecutionResult, transformResult = DEFAULT_TRANSFORM_RESULT_FN) {
    const headersInit = {
        Connection: "keep-alive",
        "Content-Type": 'multipart/mixed; boundary="-"',
        "Transfer-Encoding": "chunked",
    };
    const responseInit = {
        headers: headersInit,
        status: 200,
    };
    let iterator;
    const readableStream = new ReadableStream({
        async start(controller) {
            iterator = asyncExecutionResult[Symbol.asyncIterator]();
            controller.enqueue(`---`);
        },
        async pull(controller) {
            const { done, value } = await iterator.next();
            if (done) {
                queueMicrotask(() => {
                    controller.enqueue("\r\n-----\r\n");
                    controller.close();
                });
            }
            else {
                const transformedResult = transformResult(value);
                const chunk = JSON.stringify(transformedResult);
                const encodedChunk = encodeString(chunk);
                controller.enqueue('\r\n');
                controller.enqueue('Content-Type: application/json; charset=utf-8\r\n');
                controller.enqueue('Content-Length: ' + encodedChunk.byteLength + '\r\n');
                controller.enqueue('\r\n');
                controller.enqueue(encodedChunk);
                if (value.hasNext) {
                    controller.enqueue("\r\n---");
                }
            }
        },
        async cancel() {
            var _a;
            await ((_a = iterator.return) === null || _a === void 0 ? void 0 : _a.call(iterator));
        }
    });
    return new Response(readableStream, responseInit);
}
export function getPushResponse(asyncExecutionResult, transformResult = DEFAULT_TRANSFORM_RESULT_FN) {
    const headersInit = {
        "Content-Type": "text/event-stream",
        Connection: "keep-alive",
        "Cache-Control": "no-cache",
    };
    const responseInit = {
        headers: headersInit,
        status: 200,
    };
    let iterator;
    const readableStream = new ReadableStream({
        async start() {
            iterator = asyncExecutionResult[Symbol.asyncIterator]();
        },
        async pull(controller) {
            const { done, value } = await iterator.next();
            if (done) {
                queueMicrotask(() => {
                    controller.close();
                });
            }
            else {
                const transformedResult = transformResult(value);
                const chunk = JSON.stringify(transformedResult);
                controller.enqueue(`data: ${chunk}\n\n`);
            }
        },
        async cancel() {
            var _a;
            await ((_a = iterator.return) === null || _a === void 0 ? void 0 : _a.call(iterator));
        }
    });
    return new Response(readableStream, responseInit);
}
async function* getSingleResult(payload) {
    yield payload;
}
export function getErrorResponse({ message, status = 500, headers = {}, errors = [new Error(message)], transformResult = DEFAULT_TRANSFORM_RESULT_FN, isEventStream, }) {
    const payload = {
        errors: errors.map((error) => ({ name: error.name, message: error.message, stack: error.stack })),
    };
    if (isEventStream) {
        return getPushResponse(getSingleResult(payload), transformResult);
    }
    return new Response(JSON.stringify(transformResult(payload)), {
        status,
        headers,
    });
}
