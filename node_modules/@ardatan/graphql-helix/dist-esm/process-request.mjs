import { execute as defaultExecute, getOperationAST, parse as defaultParse, subscribe as defaultSubscribe, validate as defaultValidate, } from "graphql";
import { isAsyncIterable } from './util/is-async-iterable.mjs';
import { getMultipartResponse, getPushResponse, getRegularResponse, getErrorResponse } from './util/get-response.mjs';
const parseQuery = async (query, parse) => {
    if (typeof query !== "string" && query.kind === "Document") {
        return query;
    }
    return parse(query);
};
const getExecutableOperation = (document, operationName) => {
    const operation = getOperationAST(document, operationName);
    if (!operation) {
        throw new Error("Could not determine what operation to execute.");
    }
    return operation;
};
export const processRequest = async (options) => {
    const { contextFactory, execute = defaultExecute, formatPayload = ({ payload }) => payload, operationName, parse = defaultParse, query, request, rootValueFactory, schema, subscribe = defaultSubscribe, validate = defaultValidate, validationRules, variables, } = options;
    const transformResult = (payload) => formatPayload({
        payload,
        context,
        rootValue,
        document,
        operation,
    });
    let context;
    let rootValue;
    let document;
    let operation;
    const isEventStream = request.headers.get('accept') === "text/event-stream";
    try {
        if (request.method !== "GET" && request.method !== "POST") {
            return getErrorResponse({
                status: 405,
                message: "GraphQL only supports GET and POST requests.",
                headers: {
                    Allow: "GET, POST",
                },
                transformResult,
                isEventStream,
            });
        }
        if (query == null) {
            return getErrorResponse({
                status: 400,
                message: "Must provide query string.",
                transformResult,
                isEventStream,
            });
        }
        try {
            document = await parseQuery(query, parse);
        }
        catch (e) {
            return getErrorResponse({
                status: 400,
                message: "Syntax error",
                errors: [e],
                transformResult,
                isEventStream,
            });
        }
        const validationErrors = validate(schema, document, validationRules);
        if (validationErrors.length > 0) {
            return getErrorResponse({
                status: 400,
                message: "Invalid query.",
                errors: validationErrors,
                transformResult,
                isEventStream,
            });
        }
        operation = getExecutableOperation(document, operationName);
        if (operation.operation === "mutation" && request.method === "GET") {
            return getErrorResponse({
                status: 405,
                message: "Can only perform a mutation operation from a POST request.",
                headers: {
                    Allow: "POST",
                },
                transformResult,
                isEventStream,
            });
        }
        let variableValues;
        try {
            if (variables) {
                variableValues = typeof variables === "string" ? JSON.parse(variables) : variables;
            }
        }
        catch (_error) {
            return getErrorResponse({
                message: "Variables are invalid JSON.",
                status: 400,
                transformResult,
                isEventStream,
            });
        }
        const executionContext = {
            request,
            document,
            operation,
            variables: variableValues,
        };
        context = contextFactory ? await contextFactory(executionContext) : {};
        rootValue = rootValueFactory ? await rootValueFactory(executionContext) : {};
        if (operation.operation === "subscription") {
            const result = await subscribe({
                schema,
                document,
                rootValue,
                contextValue: context,
                variableValues,
                operationName,
            });
            // If errors are encountered while subscribing to the operation, an execution result
            // instead of an AsyncIterable.
            if (isAsyncIterable(result)) {
                return getPushResponse(result, transformResult);
            }
            else {
                if (isEventStream) {
                    return getPushResponse(result, transformResult);
                }
                else {
                    return getRegularResponse(result, transformResult);
                }
            }
        }
        else {
            const result = await execute({
                schema,
                document,
                rootValue,
                contextValue: context,
                variableValues,
                operationName,
            });
            // Operations that use @defer, @stream and @live will return an `AsyncIterable` instead of an
            // execution result.
            if (isAsyncIterable(result)) {
                return isEventStream
                    ? getPushResponse(result, transformResult)
                    : getMultipartResponse(result, transformResult);
            }
            else {
                return getRegularResponse(result, transformResult);
            }
        }
    }
    catch (error) {
        const errors = Array.isArray(error) ? error : error.errors || [error];
        return getErrorResponse({ message: "Error", status: 500, errors, isEventStream, transformResult });
    }
};
