"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getErrorResponse = exports.getPushResponse = exports.getMultipartResponse = exports.getRegularResponse = exports.DEFAULT_TRANSFORM_RESULT_FN = void 0;
const cross_undici_fetch_1 = require("cross-undici-fetch");
const encode_string_1 = require("./encode-string");
const DEFAULT_TRANSFORM_RESULT_FN = (result) => result;
exports.DEFAULT_TRANSFORM_RESULT_FN = DEFAULT_TRANSFORM_RESULT_FN;
function getRegularResponse(executionResult, transformResult = exports.DEFAULT_TRANSFORM_RESULT_FN) {
    const transformedResult = transformResult(executionResult);
    const responseBody = JSON.stringify(transformedResult);
    const decodedString = (0, encode_string_1.encodeString)(responseBody);
    const headersInit = {
        "Content-Type": "application/json",
        "Content-Length": decodedString.byteLength.toString(),
    };
    const responseInit = {
        headers: headersInit,
        status: 200,
    };
    return new cross_undici_fetch_1.Response(decodedString, responseInit);
}
exports.getRegularResponse = getRegularResponse;
function getMultipartResponse(asyncExecutionResult, transformResult = exports.DEFAULT_TRANSFORM_RESULT_FN) {
    const headersInit = {
        Connection: "keep-alive",
        "Content-Type": 'multipart/mixed; boundary="-"',
        "Transfer-Encoding": "chunked",
    };
    const responseInit = {
        headers: headersInit,
        status: 200,
    };
    let iterator;
    const readableStream = new cross_undici_fetch_1.ReadableStream({
        async start(controller) {
            iterator = asyncExecutionResult[Symbol.asyncIterator]();
            controller.enqueue(`---`);
        },
        async pull(controller) {
            const { done, value } = await iterator.next();
            if (done) {
                queueMicrotask(() => {
                    controller.enqueue("\r\n-----\r\n");
                    controller.close();
                });
            }
            else {
                const transformedResult = transformResult(value);
                const chunk = JSON.stringify(transformedResult);
                const encodedChunk = (0, encode_string_1.encodeString)(chunk);
                controller.enqueue('\r\n');
                controller.enqueue('Content-Type: application/json; charset=utf-8\r\n');
                controller.enqueue('Content-Length: ' + encodedChunk.byteLength + '\r\n');
                controller.enqueue('\r\n');
                controller.enqueue(encodedChunk);
                if (value.hasNext) {
                    controller.enqueue("\r\n---");
                }
            }
        },
        async cancel() {
            var _a;
            await ((_a = iterator.return) === null || _a === void 0 ? void 0 : _a.call(iterator));
        }
    });
    return new cross_undici_fetch_1.Response(readableStream, responseInit);
}
exports.getMultipartResponse = getMultipartResponse;
function getPushResponse(asyncExecutionResult, transformResult = exports.DEFAULT_TRANSFORM_RESULT_FN) {
    const headersInit = {
        "Content-Type": "text/event-stream",
        Connection: "keep-alive",
        "Cache-Control": "no-cache",
    };
    const responseInit = {
        headers: headersInit,
        status: 200,
    };
    let iterator;
    const readableStream = new cross_undici_fetch_1.ReadableStream({
        async start() {
            iterator = asyncExecutionResult[Symbol.asyncIterator]();
        },
        async pull(controller) {
            const { done, value } = await iterator.next();
            if (done) {
                queueMicrotask(() => {
                    controller.close();
                });
            }
            else {
                const transformedResult = transformResult(value);
                const chunk = JSON.stringify(transformedResult);
                controller.enqueue(`data: ${chunk}\n\n`);
            }
        },
        async cancel() {
            var _a;
            await ((_a = iterator.return) === null || _a === void 0 ? void 0 : _a.call(iterator));
        }
    });
    return new cross_undici_fetch_1.Response(readableStream, responseInit);
}
exports.getPushResponse = getPushResponse;
async function* getSingleResult(payload) {
    yield payload;
}
function getErrorResponse({ message, status = 500, headers = {}, errors = [new Error(message)], transformResult = exports.DEFAULT_TRANSFORM_RESULT_FN, isEventStream, }) {
    const payload = {
        errors: errors.map((error) => ({ name: error.name, message: error.message, stack: error.stack })),
    };
    if (isEventStream) {
        return getPushResponse(getSingleResult(payload), transformResult);
    }
    return new cross_undici_fetch_1.Response(JSON.stringify(transformResult(payload)), {
        status,
        headers,
    });
}
exports.getErrorResponse = getErrorResponse;
