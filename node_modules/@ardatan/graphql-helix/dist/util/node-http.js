"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendNodeResponse = exports.getNodeRequest = void 0;
const cross_undici_fetch_1 = require("cross-undici-fetch");
const is_async_iterable_1 = require("./is-async-iterable");
async function getNodeRequest(nodeRequest) {
    const fullUrl = `${nodeRequest.protocol || "http"}://${nodeRequest.hostname || nodeRequest.headers.host || "localhost"}${nodeRequest.url || "/graphql"}`;
    const maybeParsedBody = nodeRequest.body;
    const rawRequest = nodeRequest.raw || nodeRequest.req || nodeRequest;
    if (nodeRequest.method !== "POST") {
        return new cross_undici_fetch_1.Request(fullUrl, {
            headers: nodeRequest.headers,
            method: nodeRequest.method,
        });
    }
    else if (maybeParsedBody) {
        const request = new cross_undici_fetch_1.Request(fullUrl, {
            headers: nodeRequest.headers,
            method: nodeRequest.method,
        });
        Object.defineProperties(request, {
            json: {
                value: async () => maybeParsedBody,
            },
            text: {
                value: async () => JSON.stringify(maybeParsedBody),
            },
            body: {
                get: () => new cross_undici_fetch_1.Request(fullUrl, {
                    method: "POST",
                    body: JSON.stringify(maybeParsedBody),
                }).body,
            },
        });
        return request;
    }
    else if ((0, is_async_iterable_1.isAsyncIterable)(rawRequest)) {
        let iterator;
        const body = new cross_undici_fetch_1.ReadableStream({
            async start() {
                iterator = rawRequest[Symbol.asyncIterator]();
            },
            async pull(controller) {
                const { done, value } = await iterator.next();
                if (done) {
                    queueMicrotask(() => {
                        controller.close();
                    });
                }
                else {
                    controller.enqueue(value);
                }
            },
            async cancel() {
                var _a;
                await ((_a = iterator.return) === null || _a === void 0 ? void 0 : _a.call(iterator));
            }
        });
        return new cross_undici_fetch_1.Request(fullUrl, {
            headers: nodeRequest.headers,
            method: nodeRequest.method,
            body,
        });
    }
    throw new Error(`Unknown request`);
}
exports.getNodeRequest = getNodeRequest;
async function sendNodeResponse(responseResult, serverResponseOrHttp2Response) {
    const serverResponse = serverResponseOrHttp2Response;
    responseResult.headers.forEach((value, name) => {
        serverResponse.setHeader(name, value);
    });
    serverResponse.statusCode = responseResult.status;
    serverResponse.statusMessage = responseResult.statusText;
    // Some fetch implementations like `node-fetch`, return `Response.body` as Promise
    const responseBody = await responseResult.body;
    if (responseBody != null) {
        // If the response body is a NodeJS Readable stream, we can pipe it to the response directly
        if (typeof responseBody.pipe === "function") {
            responseBody.pipe(serverResponse);
        }
        else {
            // If it is a buffer
            if (responseBody instanceof Uint8Array) {
                serverResponse.write(responseBody);
                // If it is an AsyncIterable
            }
            else if ((0, is_async_iterable_1.isAsyncIterable)(responseBody)) {
                for await (const chunk of responseBody) {
                    if (chunk) {
                        serverResponse.write(chunk);
                    }
                }
                // If it is a real ReadableStream
            }
            else if (typeof responseBody.getReader === "function") {
                const reader = responseBody.getReader();
                const asyncIterable = {
                    [Symbol.asyncIterator]: () => {
                        const reader = responseBody.getReader();
                        return {
                            next: () => reader.read(),
                        };
                    },
                };
                for await (const chunk of asyncIterable) {
                    if (chunk) {
                        serverResponse.write(chunk);
                    }
                }
                serverResponse.on("close", () => {
                    reader.releaseLock();
                });
            }
            serverResponse.end();
        }
    }
}
exports.sendNodeResponse = sendNodeResponse;
