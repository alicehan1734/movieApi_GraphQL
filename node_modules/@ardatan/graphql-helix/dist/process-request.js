"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processRequest = void 0;
const graphql_1 = require("graphql");
const is_async_iterable_1 = require("./util/is-async-iterable");
const get_response_1 = require("./util/get-response");
const parseQuery = async (query, parse) => {
    if (typeof query !== "string" && query.kind === "Document") {
        return query;
    }
    return parse(query);
};
const getExecutableOperation = (document, operationName) => {
    const operation = (0, graphql_1.getOperationAST)(document, operationName);
    if (!operation) {
        throw new Error("Could not determine what operation to execute.");
    }
    return operation;
};
const processRequest = async (options) => {
    const { contextFactory, execute = graphql_1.execute, formatPayload = ({ payload }) => payload, operationName, parse = graphql_1.parse, query, request, rootValueFactory, schema, subscribe = graphql_1.subscribe, validate = graphql_1.validate, validationRules, variables, } = options;
    const transformResult = (payload) => formatPayload({
        payload,
        context,
        rootValue,
        document,
        operation,
    });
    let context;
    let rootValue;
    let document;
    let operation;
    const isEventStream = request.headers.get('accept') === "text/event-stream";
    try {
        if (request.method !== "GET" && request.method !== "POST") {
            return (0, get_response_1.getErrorResponse)({
                status: 405,
                message: "GraphQL only supports GET and POST requests.",
                headers: {
                    Allow: "GET, POST",
                },
                transformResult,
                isEventStream,
            });
        }
        if (query == null) {
            return (0, get_response_1.getErrorResponse)({
                status: 400,
                message: "Must provide query string.",
                transformResult,
                isEventStream,
            });
        }
        try {
            document = await parseQuery(query, parse);
        }
        catch (e) {
            return (0, get_response_1.getErrorResponse)({
                status: 400,
                message: "Syntax error",
                errors: [e],
                transformResult,
                isEventStream,
            });
        }
        const validationErrors = validate(schema, document, validationRules);
        if (validationErrors.length > 0) {
            return (0, get_response_1.getErrorResponse)({
                status: 400,
                message: "Invalid query.",
                errors: validationErrors,
                transformResult,
                isEventStream,
            });
        }
        operation = getExecutableOperation(document, operationName);
        if (operation.operation === "mutation" && request.method === "GET") {
            return (0, get_response_1.getErrorResponse)({
                status: 405,
                message: "Can only perform a mutation operation from a POST request.",
                headers: {
                    Allow: "POST",
                },
                transformResult,
                isEventStream,
            });
        }
        let variableValues;
        try {
            if (variables) {
                variableValues = typeof variables === "string" ? JSON.parse(variables) : variables;
            }
        }
        catch (_error) {
            return (0, get_response_1.getErrorResponse)({
                message: "Variables are invalid JSON.",
                status: 400,
                transformResult,
                isEventStream,
            });
        }
        const executionContext = {
            request,
            document,
            operation,
            variables: variableValues,
        };
        context = contextFactory ? await contextFactory(executionContext) : {};
        rootValue = rootValueFactory ? await rootValueFactory(executionContext) : {};
        if (operation.operation === "subscription") {
            const result = await subscribe({
                schema,
                document,
                rootValue,
                contextValue: context,
                variableValues,
                operationName,
            });
            // If errors are encountered while subscribing to the operation, an execution result
            // instead of an AsyncIterable.
            if ((0, is_async_iterable_1.isAsyncIterable)(result)) {
                return (0, get_response_1.getPushResponse)(result, transformResult);
            }
            else {
                if (isEventStream) {
                    return (0, get_response_1.getPushResponse)(result, transformResult);
                }
                else {
                    return (0, get_response_1.getRegularResponse)(result, transformResult);
                }
            }
        }
        else {
            const result = await execute({
                schema,
                document,
                rootValue,
                contextValue: context,
                variableValues,
                operationName,
            });
            // Operations that use @defer, @stream and @live will return an `AsyncIterable` instead of an
            // execution result.
            if ((0, is_async_iterable_1.isAsyncIterable)(result)) {
                return isEventStream
                    ? (0, get_response_1.getPushResponse)(result, transformResult)
                    : (0, get_response_1.getMultipartResponse)(result, transformResult);
            }
            else {
                return (0, get_response_1.getRegularResponse)(result, transformResult);
            }
        }
    }
    catch (error) {
        const errors = Array.isArray(error) ? error : error.errors || [error];
        return (0, get_response_1.getErrorResponse)({ message: "Error", status: 500, errors, isEventStream, transformResult });
    }
};
exports.processRequest = processRequest;
