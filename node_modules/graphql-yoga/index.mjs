import { createServer as createServer$2 } from 'http';
import { createServer as createServer$1 } from 'https';
import pino from 'pino';
import { sendNodeResponse, getNodeRequest } from '@ardatan/graphql-helix';
export { renderGraphiQL } from '@ardatan/graphql-helix';
import { Server as Server$1 } from '@graphql-yoga/core';
import { EnvelopError } from '@envelop/core';
export * from '@envelop/core';
export { EnvelopError as GraphQLServerError } from '@envelop/core';
import LightMyRequest from 'light-my-request';
import { print } from 'graphql';
export * from '@graphql-yoga/subscription';

function getPinoLogger(options) {
    var _a, _b;
    const prettyLog = (_a = options.prettyLog) !== null && _a !== void 0 ? _a : process.env.NODE_ENV !== 'production';
    const logLevel = ((_b = options.logLevel) !== null && _b !== void 0 ? _b : process.env.NODE_ENV !== 'production') ? 'debug' : 'info';
    const prettyPrintOptions = prettyLog
        ? {
            transport: {
                target: 'pino-pretty',
                options: {
                    translateTime: true,
                    colorize: true,
                },
            },
        }
        : {};
    return pino({
        ...prettyPrintOptions,
        level: logLevel,
        enabled: true,
    });
}
class Server extends Server$1 {
    constructor(options) {
        super({
            ...options,
            logger: options.logger || getPinoLogger(options),
        });
        this.requestListener = async (req, res) => {
            const response = await this.handleIncomingMessage(req);
            await sendNodeResponse(response, res);
        };
        this.port = options.port || parseInt(process.env.PORT || '4000');
        this.endpoint = options.endpoint || '/graphql';
        this.hostname = options.hostname || '0.0.0.0';
        this.logger.debug('Setting up server.');
        if (options.https) {
            this._server =
                typeof options.https === 'object'
                    ? createServer$1(options.https, this.requestListener)
                    : createServer$1(this.requestListener);
        }
        else {
            this._server = createServer$2(this.requestListener);
        }
        if (this.graphiql) {
            this.graphiql.endpoint = this.endpoint;
        }
    }
    async handleIncomingMessage(...args) {
        this.logger.debug('Node Request received');
        const request = await getNodeRequest(...args);
        this.logger.debug('Node Request processed');
        const response = await this.handleRequest(request);
        this.logger.debug('Response returned');
        return response;
    }
    get server() {
        return this._server;
    }
    start(callback = () => {
        this.logger.info(`GraphQL Server running at http://${this.hostname}:${this.port}${this.endpoint}.`);
    }) {
        return new Promise((resolve) => {
            this._server.listen(this.port, this.hostname, () => {
                callback();
                resolve();
            });
        });
    }
    stop(callback = (err) => {
        if (err) {
            this.logger.error('Something went wrong :( trying to shutdown the server.', err);
        }
        else {
            this.logger.info('Shutting down GraphQL server.');
        }
    }) {
        return new Promise((resolve, reject) => {
            this._server.close((err) => {
                callback(err);
                if (err != null) {
                    reject(new EnvelopError(err.message));
                }
                else {
                    resolve();
                }
            });
        });
    }
    /**
     * Testing utility to mock http request for GraphQL endpoint
     *
     *
     * Example - Test a simple query
     * ```ts
     * const response = await yoga.inject({
     *  document: "query { ping }",
     * })
     * expect(response.statusCode).toBe(200)
     * expect(response.data.ping).toBe('pong')
     * ```
     **/
    async inject({ document, variables, operationName, headers, }) {
        const response = await LightMyRequest.inject(this.requestListener, {
            method: 'POST',
            url: this.endpoint,
            headers,
            payload: JSON.stringify({
                query: typeof document === 'string' ? document : print(document),
                variables,
                operationName,
            }),
        });
        return {
            response,
            get executionResult() {
                return JSON.parse(response.payload);
            },
        };
    }
}
/**
 * Create a simple yet powerful GraphQL server ready for production workloads.
 * Spec compliant server that supports bleeding edge GraphQL features without any vendor lock-ins.
 *
 * Comes baked in with:
 *
 * - Envelop - Plugin system for GraphQL
 * - GraphQL Helix - Extensible and Framework agnostic GraphQL server
 * - GraphiQL - GraphQL IDE for your browser
 * - Pino - Super fast, low overhead Node.js logger
 *
 * Example:
 * ```ts
 *  import { schema } from './schema'
 *   // Provide a GraphQL schema
 *  const server = createServer({ schema })
 *  // Start the server. Defaults to http://localhost:4000/graphql
 *  server.start()
 * ```
 */
function createServer(options) {
    return new Server(options);
}

export { createServer };
