'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

const http = require('http');
const https = require('https');
const pino = _interopDefault(require('pino'));
const graphqlHelix = require('@ardatan/graphql-helix');
const core = require('@graphql-yoga/core');
const core$1 = require('@envelop/core');
const LightMyRequest = _interopDefault(require('light-my-request'));
const graphql = require('graphql');
const subscription = require('@graphql-yoga/subscription');

function getPinoLogger(options) {
    var _a, _b;
    const prettyLog = (_a = options.prettyLog) !== null && _a !== void 0 ? _a : process.env.NODE_ENV !== 'production';
    const logLevel = ((_b = options.logLevel) !== null && _b !== void 0 ? _b : process.env.NODE_ENV !== 'production') ? 'debug' : 'info';
    const prettyPrintOptions = prettyLog
        ? {
            transport: {
                target: 'pino-pretty',
                options: {
                    translateTime: true,
                    colorize: true,
                },
            },
        }
        : {};
    return pino({
        ...prettyPrintOptions,
        level: logLevel,
        enabled: true,
    });
}
class Server extends core.Server {
    constructor(options) {
        super({
            ...options,
            logger: options.logger || getPinoLogger(options),
        });
        this.requestListener = async (req, res) => {
            const response = await this.handleIncomingMessage(req);
            await graphqlHelix.sendNodeResponse(response, res);
        };
        this.port = options.port || parseInt(process.env.PORT || '4000');
        this.endpoint = options.endpoint || '/graphql';
        this.hostname = options.hostname || '0.0.0.0';
        this.logger.debug('Setting up server.');
        if (options.https) {
            this._server =
                typeof options.https === 'object'
                    ? https.createServer(options.https, this.requestListener)
                    : https.createServer(this.requestListener);
        }
        else {
            this._server = http.createServer(this.requestListener);
        }
        if (this.graphiql) {
            this.graphiql.endpoint = this.endpoint;
        }
    }
    async handleIncomingMessage(...args) {
        this.logger.debug('Node Request received');
        const request = await graphqlHelix.getNodeRequest(...args);
        this.logger.debug('Node Request processed');
        const response = await this.handleRequest(request);
        this.logger.debug('Response returned');
        return response;
    }
    get server() {
        return this._server;
    }
    start(callback = () => {
        this.logger.info(`GraphQL Server running at http://${this.hostname}:${this.port}${this.endpoint}.`);
    }) {
        return new Promise((resolve) => {
            this._server.listen(this.port, this.hostname, () => {
                callback();
                resolve();
            });
        });
    }
    stop(callback = (err) => {
        if (err) {
            this.logger.error('Something went wrong :( trying to shutdown the server.', err);
        }
        else {
            this.logger.info('Shutting down GraphQL server.');
        }
    }) {
        return new Promise((resolve, reject) => {
            this._server.close((err) => {
                callback(err);
                if (err != null) {
                    reject(new core$1.EnvelopError(err.message));
                }
                else {
                    resolve();
                }
            });
        });
    }
    /**
     * Testing utility to mock http request for GraphQL endpoint
     *
     *
     * Example - Test a simple query
     * ```ts
     * const response = await yoga.inject({
     *  document: "query { ping }",
     * })
     * expect(response.statusCode).toBe(200)
     * expect(response.data.ping).toBe('pong')
     * ```
     **/
    async inject({ document, variables, operationName, headers, }) {
        const response = await LightMyRequest.inject(this.requestListener, {
            method: 'POST',
            url: this.endpoint,
            headers,
            payload: JSON.stringify({
                query: typeof document === 'string' ? document : graphql.print(document),
                variables,
                operationName,
            }),
        });
        return {
            response,
            get executionResult() {
                return JSON.parse(response.payload);
            },
        };
    }
}
/**
 * Create a simple yet powerful GraphQL server ready for production workloads.
 * Spec compliant server that supports bleeding edge GraphQL features without any vendor lock-ins.
 *
 * Comes baked in with:
 *
 * - Envelop - Plugin system for GraphQL
 * - GraphQL Helix - Extensible and Framework agnostic GraphQL server
 * - GraphiQL - GraphQL IDE for your browser
 * - Pino - Super fast, low overhead Node.js logger
 *
 * Example:
 * ```ts
 *  import { schema } from './schema'
 *   // Provide a GraphQL schema
 *  const server = createServer({ schema })
 *  // Start the server. Defaults to http://localhost:4000/graphql
 *  server.start()
 * ```
 */
function createServer(options) {
    return new Server(options);
}

Object.keys(core$1).forEach(function (k) {
    if (k !== 'default') Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
            return core$1[k];
        }
    });
});
Object.keys(subscription).forEach(function (k) {
    if (k !== 'default') Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
            return subscription[k];
        }
    });
});
Object.defineProperty(exports, 'renderGraphiQL', {
    enumerable: true,
    get: function () {
        return graphqlHelix.renderGraphiQL;
    }
});
Object.defineProperty(exports, 'GraphQLServerError', {
    enumerable: true,
    get: function () {
        return core$1.EnvelopError;
    }
});
exports.createServer = createServer;
